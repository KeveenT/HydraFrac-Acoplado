import sys,os,io,shutil
sys.path.append(os.path.join(os.path.dirname(__file__), os.path.pardir))
from PyEFVLib import MSHReader, Grid, ProblemData, CsvSaver, NeumannBoundaryCondition, DirichletBoundaryCondition, BoundaryCondition
from apps.heat_transfer import heatTransfer
from apps.stress_equilibrium import stressEquilibrium

import tkinter as tk
from tkinter import filedialog, ttk, messagebox, scrolledtext

import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap as CM, Normalize

from PIL import ImageTk, Image

from contextlib import redirect_stdout
import numpy as np
from numpy import pi, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, arctanh, sqrt, e , log, exp, inf, mod, floor
import pandas as pd
from scipy.interpolate import griddata

def getFunction(expr, conversion=lambda x:x):
	def function(x,y,z,t=0.0):
		return conversion( eval( expr.replace('x',str(x)).replace('y',str(y)).replace('z',str(z)).replace('t',str(t)) ) )
	return function

class PyEFVLibGUI:
	def __init__(self):
		self.root = tk.Tk()
		self.ttkStyle = ttk.Style()
		self.ttkStyle.theme_use("winnative")
		self.root.title("PyEFVLib GUI")
		# self.root.iconbitmap(os.path.join( os.path.dirname(__file__), "icon.ico" ))
		self.root.bind("<Key>", lambda key: self.root.destroy() if key.char=="\x17" else 0) # Close window if Ctrl+W is pressed

		self.HEIGHT, self.WIDTH = (500, 600)

		self.init()

		self.root.mainloop()

	def init(self):
		self.root.title("PyEFVLib GUI")
		self.mainMenu = MainMenu(self.root, self)
		self.geoMesh = GeoMesh(self.root, self)
		self.heatTransferSimulator = HeatTransferSimulator(self.root, self)
		self.solidMechanicsSimulator = SolidMechanicsSimulator(self.root, self)
		self.post = Post(self.root, self)

		self.mainMenu.init()

class MainMenu:
	def __init__(self, root, application):
		self.root = root
		self.app = application

	def init(self):
		self.populate()
		self.show()

	def populate(self):
		self.page = tk.Frame(self.root, width=300, height=250)
		centerFrame = tk.Frame(self.page)

		heatTransferButton = tk.Button(centerFrame, text="Heat Transfer Simulator", command=self.openHeatTransfer)
		heatTransferButton.bind('<Return>', lambda e:self.openHeatTransfer())
		heatTransferButton.grid(row=0, sticky=["w","e"])

		solidMechanicsButton = tk.Button(centerFrame, text="Solid Mechanics Simulator", command=self.openSolidMechanics)
		solidMechanicsButton.bind('<Return>', lambda e:self.openSolidMechanics())
		solidMechanicsButton.grid(row=1, sticky=["w","e"])

		postButton = tk.Button(centerFrame, text="Post", command=self.openPost)
		postButton.bind('<Return>', lambda e:self.openPost())
		postButton.grid(row=2, sticky=["w","e"])

		centerFrame.place(relx=0.5, rely=0.35-0.02, anchor="n")

	def show(self):
		self.page.pack(side="top", fill="both", expand=1)

	def openHeatTransfer(self):
		self.page.destroy()
		self.app.heatTransferSimulator.init()

	def openSolidMechanics(self):
		self.page.destroy()
		self.app.solidMechanicsSimulator.init()

	def openPost(self):
		tk.messagebox.showinfo("Select a result file", "Select a file generated by PyEFVLib simulation")
		initialdir = os.path.join(os.path.dirname(__file__), os.path.pardir, "results")
		resultsFileName = tk.filedialog.askopenfilename(initialdir=initialdir, title="Select a result file", filetypes=(("CSV files", "*.csv"),("All files", "*")))
		if resultsFileName:
			self.page.destroy()
			self.app.post.setResultsPath( os.path.realpath( resultsFileName ) )
			self.app.post.init()

class Page(tk.Canvas):
	def __init__(self, root, width, height, prevFunc, nextFunc):
		tk.Canvas.__init__(self, root, width=width, height=height)
		self.root = root
		self.prevFunc = prevFunc
		self.nextFunc = nextFunc

		self.placeFooter()

	def placeFooter(self):
		self.footerFrame = tk.Frame(self)
		self.footerFrame.place(relx=0.02, rely=1.00-0.02, relwidth=1.00-0.04, relheight=0.10-0.02, anchor="sw")

		self.prevButton = tk.Button(self.footerFrame, text="Prev", command=self.prevFunc)
		self.prevButton.bind('<Return>', lambda e:self.prevFunc())
		self.prevButton.place(relx=0.80-0.02, rely=0.50, relheight=0.75, relwidth=0.20, anchor="e")

		self.nextButton = tk.Button(self.footerFrame, text="Next", command=self.nextFunc)
		self.nextButton.bind('<Return>', lambda e:self.nextFunc())
		self.nextButton.place(relx=1.0, rely=0.50, relheight=0.75, relwidth=0.20, anchor="e")

	def show(self):
		self.pack(side="left", fill="both", expand=1)

	def hide(self):
		self.pack_forget()

class GeoMesh:
	def __init__(self, root, application):
		self.root = root
		self.app = application

		self.settings()

	def __del__(self):
		if os.path.exists(self.tempPath):
			os.remove(self.tempPath)

	def settings(self):
		self.tempPath = os.path.join( os.path.dirname(__file__), "temp.msh" )

		self.parameters = {
			"rectangle": ["width", "height", "dx", "dy"],
			"polar": ["r1", "r2", "θ", "dr", "dθ"]
		}
		self.writers = { "rectangle": self.writeRectangle, "polar": self.writePolar }
		
		length = ["m", "cm", "km", "mm",]
		angle = ["°", "rad",]
		self.units = {
			"width":length, "height":length, "dx":length, "dy":length,
			"r1":length, "r2":length, "θ":angle, "dr":length, "dθ":angle
		}
		self.unitsConvert = {
			"m": lambda x: 1.0 * x,
			"cm": lambda x: 0.01 * x,
			"km": lambda x: 1000.0 * x,
			"mm": lambda x: 0.001 * x,
			"°": lambda x: np.pi * x / 180.0,
			"rad": lambda x: 1.0 * x
		}

	def initPre(self):
		self.popupGeometrySelection()

	def initContour(self):
		self.simulator.page1.hide()
		self.populatePage2()

	def populatePage1(self):
		def prevFunc():
			self.page1.hide()
			self.simulator.page1.show()
		def nextFunc():
			previewMesh()
			self.page1.hide()
			self.simulator.page1.show()
			self.simulator.readFile(self.tempPath)

		self.page1 = Page(self.root, width=600, height=500, prevFunc=prevFunc, nextFunc=nextFunc)
		self.page1.show()

		def previewMesh():
			if "" in [ param.get() for param in self.parameterEntries]:
				messagebox.showerror("Error", "All rectangle parameters must be positive")
				raise Exception("All rectangle parameters must be positive")

			try:
				values = [ float( param.get() ) for param in self.parameterEntries]
			except:
				messagebox.showerror("Error", "Invalid input")
				raise Exception("Invalid input")

			values = [ self.unitsConvert[ unitVar.get() ](value) for value, unitVar in zip(values, self.parameterUnits) ]

			self.writers[self.geometry]( *values, self.tempPath )

			self.drawMesh(self.meshAx, self.matplotlibMeshCanvas, self.tempPath)

		def meshPlacement():
			# Mesh
			self.meshCanvas = tk.Canvas(self.page1)

			self.meshFigure = matplotlib.figure.Figure()
			self.meshAx = self.meshFigure.add_subplot()
			self.meshAx.set_position([0.2,0.05,0.6,0.95])

			plt.setp(self.meshAx.xaxis.get_ticklabels(), visible=False) 
			plt.setp(self.meshAx.yaxis.get_ticklabels(), visible=False) 

			self.meshFigure.patch.set_facecolor((240/255,240/255,237/255))
			self.meshAx.patch.set_facecolor((240/255,240/255,237/255))

			self.matplotlibMeshCanvas = FigureCanvasTkAgg(self.meshFigure, self.meshCanvas)
			self.matplotlibWidget = self.matplotlibMeshCanvas.get_tk_widget()
			self.matplotlibWidget.pack(side="left", fill="both", expand=1)

			self.meshCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.5,anchor="nw")
		def geometrySettings():
			self.meshSettingsFrame = tk.LabelFrame(self.page1, text="Mesh Settings")
			self.meshSettingsFrame.place(relx=0.02,rely=0.52,relwidth=1.00-0.04,relheight=0.36,anchor="nw")

			centerFrame = tk.Frame(self.meshSettingsFrame)
			centerFrame.pack()

			self.parameterEntries = []
			self.parameterUnits = []
			for i, eN in enumerate(self.parameters[ self.geometry ]):
				tk.Label(centerFrame, text=eN).grid(column=0, row=i, sticky="w", padx=10, pady=5)
				entry = tk.Entry(centerFrame)
				entry.bind('<Return>', lambda e:previewMesh())
				entry.grid(column=1, row=i)

				unitVar = tk.StringVar(centerFrame)
				unitVar.set(self.units[eN][0])

				unitMenu = tk.OptionMenu(centerFrame, unitVar, *self.units[eN])
				unitMenu.grid(column=2, row=i, sticky="E")


				self.parameterEntries.append( entry )
				self.parameterUnits.append( unitVar )

			previewButton = tk.Button(centerFrame, text="Preview", command=previewMesh)
			previewButton.bind('<Return>', lambda e:previewMesh())
			previewButton.grid(column=3, row=i, padx=10, pady=5)

			helpButton = tk.Button(centerFrame, text="  ?  ", command=self.preMeshPopupHelp)
			helpButton.bind('<Return>', lambda e:previewMesh())
			helpButton.grid(column=3, row=0, padx=10, pady=5)

			self.saveAsButton1 = tk.Button(self.page1.footerFrame, text="Save Mesh As", command=self.saveMeshAs)
			self.saveAsButton1.place(relx=0.0, rely=0.50, relheight=0.75, relwidth=0.20, anchor="w")

		meshPlacement()
		geometrySettings()

	def populatePage2(self):
		def prevFunc():
			if self.submenu == 0:
				self.page2.hide()
				self.simulator.page1.show()
			elif self.submenu == 1:
				self.submenu = 0
				paramsHide()
				vertexSelShow()
				self.coordinates += [ self.coordinates[0] ]
				self.vsmFuncs[0]()
		def nextFunc():
			if self.submenu == 0:
				messagebox.showerror("Error", "You must close the contour before continuing")
			elif self.submenu == 1:
				self.writePolygon()
				self.drawMesh(self.meshAx, self.matplotlibMeshCanvas, self.tempPath)

				self.page2.hide()
				self.simulator.page1.show()
				self.simulator.readFile(self.tempPath)

		self.page2 = Page(self.root, width=600, height=500, prevFunc=prevFunc, nextFunc=nextFunc)
		self.page2.show()

		def vertexSelShow():
			self.vertexFrame.place(relx=0.02,rely=0.67,relwidth=1.00-0.04,relheight=0.21,anchor="nw")
		def vertexSelHide():
			self.vertexFrame.place_forget()
		def paramsShow():
			self.dxEntry.focus_set()
			self.saveAsButton2.place(relx=0.0, rely=0.50, relheight=0.75, relwidth=0.20, anchor="w")
			self.meshParametersFrame.place(relx=0.02,rely=0.67,relwidth=1.00-0.04,relheight=0.21,anchor="nw")
		def paramsHide():
			self.saveAsButton2.place_forget()
			self.meshParametersFrame.place_forget()

		def meshPlacement():
			self.meshCanvas = tk.Canvas(self.page2)

			self.meshFigure = matplotlib.figure.Figure()
			self.meshAx = self.meshFigure.add_subplot()
			self.meshAx.set_position([0.125,0.1,0.75,0.85])

			self.meshFigure.patch.set_facecolor((240/255,240/255,237/255))
			self.meshAx.patch.set_facecolor((240/255,240/255,237/255))

			self.matplotlibMeshCanvas = FigureCanvasTkAgg(self.meshFigure, self.meshCanvas)
			self.matplotlibWidget = self.matplotlibMeshCanvas.get_tk_widget()
			self.matplotlibWidget.pack(side="left", fill="both", expand=1)

			self.meshCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.65,anchor="nw")
		def vertexSelection():
			self.coordinates = []
			self.boundaryNames = []
			def draw(clear=True):
				if clear:
					self.meshAx.clear()
				if self.coordinates:
					self.meshAx.scatter(*zip(*self.coordinates), color="k", marker=".")
					self.meshAx.plot(*zip(*self.coordinates), color="k")
				self.meshAx.patch.set_facecolor((240/255,240/255,237/255))
				self.matplotlibMeshCanvas.draw()
			def prevVertexFunc():
				xEntry.delete(0, tk.END)
				yEntry.delete(0, tk.END)
				boundaryEntry.delete(0, tk.END)

				xEntry.focus_set()
				
				if self.coordinates:
					xEntry.insert(0, str(self.coordinates[-1][0]))
					yEntry.insert(0, str(self.coordinates[-1][1]))
				if self.boundaryNames:	
					boundaryEntry.insert(0, self.boundaryNames[-1])

				if self.coordinates: self.coordinates.pop()
				if self.boundaryNames:
					self.boundaryNames.pop()
				else:
					boundaryEntry.configure(state="disabled")
					prevVertexButton.configure(state="disabled")

				self.meshAx.clear()
				if self.coordinates:
					self.meshAx.scatter(*zip(*self.coordinates), color="k", marker=".")
					self.meshAx.plot(*zip(*self.coordinates), color="k")
				self.meshAx.patch.set_facecolor((240/255,240/255,237/255))
				self.matplotlibMeshCanvas.draw()
			def nextVertexFunc():
				# Bad input handling
				if xEntry.get()=="" or yEntry.get()=="":
					messagebox.showerror("Error", "The coordinate values may not be empty")
					raise Exception("The coordinate values may not be empty")
				if self.coordinates and boundaryEntry.get()=="":
					messagebox.showerror("Error", "The boundary name field may not be empty")
					raise Exception("The boundary name field may not be empty")
				try:
					x, y = float(xEntry.get()), float(yEntry.get())
				except:
					messagebox.showerror("Error", "Invalid input")
					raise Exception("Invalid input")

				# Saving input data
				self.coordinates.append((x,y))
				if boundaryEntry.get():
					self.boundaryNames.append( boundaryEntry.get() )

				# Plotting on the canvas
				draw()

				# Checking whether loop has closed
				if len(self.coordinates) > 1 and x == self.coordinates[0][0] and y == self.coordinates[0][1]:
					self.submenu = 1
					self.coordinates.pop()
					vertexSelHide()
					paramsShow()

				# Reconfiguring frame
				xEntry.delete(0, tk.END)
				yEntry.delete(0, tk.END)
				xEntry.focus_set()
				boundaryEntry.configure(state="normal")
				prevVertexButton.configure(state="normal")

			self.vsmFuncs = [prevVertexFunc,nextVertexFunc]

			self.vertexFrame = tk.LabelFrame(self.page2)
			self.vertexFrame.place(relx=0.02,rely=0.67,relwidth=1.00-0.04,relheight=0.21,anchor="nw")

			centerFrame = tk.Frame(self.vertexFrame)
			centerFrame.pack()

			tk.Label(centerFrame, text="X").grid(column=0, row=0, sticky="w", padx=10, pady=5)
			xEntry = tk.Entry(centerFrame)
			xEntry.bind('<Return>', lambda e:nextVertexFunc())
			xEntry.grid(column=1, row=0)

			tk.Label(centerFrame, text="Y").grid(column=0, row=1, sticky="w", padx=10, pady=5)
			yEntry = tk.Entry(centerFrame)
			yEntry.bind('<Return>', lambda e:nextVertexFunc())
			yEntry.grid(column=1, row=1)

			tk.Label(centerFrame, text="Boundary Name").grid(column=0, row=2, sticky="w", padx=10, pady=5)
			boundaryEntry = tk.Entry(centerFrame, state="disabled")
			boundaryEntry.bind('<Return>', lambda e:nextVertexFunc())
			boundaryEntry.grid(column=1, row=2)

			prevVertexButton = tk.Button(centerFrame, text="  <  ", command=prevVertexFunc, state="disabled")
			prevVertexButton.bind('<Return>', lambda e:prevVertexFunc())
			prevVertexButton.grid(column=2, row=2, pady=5)

			nextVertexButton = tk.Button(centerFrame, text="  >  ", command=nextVertexFunc)
			nextVertexButton.bind('<Return>', lambda e:nextVertexFunc())
			nextVertexButton.grid(column=3, row=2, pady=5)

			def click(event):
				if self.submenu == 0 and event.button == 1:
					xc = round(event.xdata, 1)
					yc = round(event.ydata, 1)

					xEntry.delete(0, tk.END); xEntry.insert(0, str(xc))
					yEntry.delete(0, tk.END); yEntry.insert(0, str(yc))

					self.meshAx.clear()
					self.meshAx.scatter((xc,),(yc,),color="r",)
					draw(clear=False)
			def scroll(event):
				base_scale = 2

				cur_xlim = self.meshAx.get_xlim()
				cur_ylim = self.meshAx.get_ylim()
				cur_xrange = (cur_xlim[1] - cur_xlim[0])*.5
				cur_yrange = (cur_ylim[1] - cur_ylim[0])*.5
				# xpos = cur_xlim[0] + cur_xrange
				# ypos = cur_ylim[0] + cur_yrange
				xpos = event.xdata
				ypos = event.ydata

				scale_factor = base_scale if event.button=="up" else 1/base_scale if event.button=="down" else 1

				self.meshAx.set_xlim([xpos - cur_xrange*scale_factor, xpos + cur_xrange*scale_factor])
				self.meshAx.set_ylim([ypos - cur_yrange*scale_factor, ypos + cur_yrange*scale_factor])
				self.matplotlibMeshCanvas.draw()

			self.meshFigure.canvas.mpl_connect('button_press_event', click)
			self.meshFigure.canvas.mpl_connect('scroll_event', scroll)
		def meshParameters():
			def previewFunc():
				self.writePolygon()
				self.drawMesh(self.meshAx, self.matplotlibMeshCanvas, self.tempPath)

			self.meshParametersFrame = tk.LabelFrame(self.page2)
			# self.meshParametersFrame.place(relx=0.02,rely=0.67,relwidth=1.00-0.04,relheight=0.21,anchor="nw")

			centerFrame = tk.Frame(self.meshParametersFrame)
			centerFrame.pack()

			tk.Label(centerFrame, text="dx").grid(column=0, row=0, sticky="w", padx=10, pady=5)
			self.dxEntry = tk.Entry(centerFrame)
			self.dxEntry.bind('<Return>', lambda e:previewFunc())
			self.dxEntry.grid(column=1, row=0)

			tk.Label(centerFrame, text="dy").grid(column=0, row=1, sticky="w", padx=10, pady=5)
			self.dyEntry = tk.Entry(centerFrame)
			self.dyEntry.bind('<Return>', lambda e:previewFunc())
			self.dyEntry.grid(column=1, row=1)

			previewButton = tk.Button(centerFrame, text="Preview", command=previewFunc)
			previewButton.bind('<Return>', lambda e:previewFunc())
			previewButton.grid(column=2, row=1)

			self.saveAsButton2 = tk.Button(self.page2.footerFrame, text="Save Mesh As", command=self.saveMeshAs)

		self.submenu = 0
		meshPlacement()
		vertexSelection()
		meshParameters()

	def popupGeometrySelection(self):
		geoSelectionWin = tk.Toplevel()
		geoSelectionWin.geometry("{}x{}".format(300,80))
		geoSelectionWin.title("Select Mesh Option")

		geoSelectionFrame = tk.Frame(geoSelectionWin)
		geoSelectionFrame.pack()

		def rectangleCommand():
			geoSelectionWin.destroy()
			self.simulator.page1.hide()
			self.geometry = "rectangle"
			self.populatePage1()
		def polarCommand():
			geoSelectionWin.destroy()
			self.simulator.page1.hide()
			self.geometry = "polar"
			self.populatePage1()

		tk.Button(geoSelectionFrame, width=10, height=3, text="Rectangle", command=rectangleCommand).grid(column=0, row=0, padx=5, pady=5)
		tk.Button(geoSelectionFrame, width=10, height=3, text="Polar", command=polarCommand).grid(column=1, row=0, padx=5, pady=5)

	def preMeshPopupHelp(self):
		helpWin = tk.Toplevel(self.root, height=500, width=600)

		img = ImageTk.PhotoImage( Image.open( "{}_settings.png".format(self.geometry) ).resize((450, 350), Image.ANTIALIAS) )
		panel = tk.Label(helpWin, image=img)
		panel.image = img
		panel.pack()

	def setSimulator(self, simulator):
		self.simulator = simulator

	def writeRectangle(self, width, height, dx, dy, outputPath):
		if width<=0 or height<=0 or dx<=0 or dy<=0:
			messagebox.showerror("Error", "All rectangle parameters must be positive")
			raise Exception("All rectangle parameters must be positive")
		elif dx > width:
			messagebox.showerror("Error", "dx must be less than width")
			raise Exception("dx must be less than width")
		elif dy > height:
			messagebox.showerror("Error", "dy must be less than height")
			raise Exception("dy must be less than height")

		nx = int(width/dx) + 1
		ny = int(height/dy) + 1

		physicalNames = { "Body":2, "North":1, "South":1, "West":1, "East":1 }
		nodes = [(x,y,0.0) for y in np.linspace(0,height,ny) for x in np.linspace(0,width,nx)]

		elements = []
		elements += [[len(elements)+i+1, *(1, 2), *(2, 2), *(vIdx+1,vIdx+2)] for i, vIdx in enumerate( range(nx*(ny-1), nx*ny-1) )]
		elements += [[len(elements)+i+1, *(1, 2), *(3, 3), *(vIdx+1,vIdx+2)] for i, vIdx in enumerate( range(0, nx-1) )]
		elements += [[len(elements)+i+1, *(1, 2), *(4, 4), *(vIdx+1,vIdx+nx+1)] for i, vIdx in enumerate( range(0, nx*(ny-1), nx) )]
		elements += [[len(elements)+i+1, *(1, 2), *(5, 5), *(vIdx+1,vIdx+nx+1)] for i, vIdx in enumerate( range(nx-1, nx*ny-1, nx) )]
		elements += [[len(elements)+i+1, *(3, 2), *(1, 1), *(vIdx+1, vIdx+2, vIdx+2+nx, vIdx+1+nx)] for i, vIdx in enumerate( [ vIdx for vIdx in range(nx*ny-nx-1) if (vIdx+1)%nx!=0 ] )]

		text = ""
		text += "$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$PhysicalNames\n"
		text += str( len(physicalNames) ) + "\n"
		text += "".join([ "{} {} \"{}\"\n".format(physicalNames[name], idx+1, name) for idx, name in enumerate(physicalNames.keys()) ])
		text += "$EndPhysicalNames\n$Nodes\n"
		text += str( len(nodes) ) + "\n"
		text += "".join([ "{} {} {} {}\n".format(idx+1, x, y, z) for idx,(x,y,z) in enumerate(nodes) ])
		text += "$EndNodes\n$Elements\n"
		text += str( len(elements) ) + "\n"
		text += "\n".join([" ".join([str(ev) for ev in e]) for e in elements])
		text += "\n$EndElements\n"

		with open(outputPath, "w") as f:
			f.write(text)

	def writePolar(self, r1,r2,angle, dr, dTheta, outputPath):
		if r1<=0.0 or r2<=0.0 or angle<=0.0 or dr<=0 or dTheta<=0:
			messagebox.showerror("Error","All parameters must be positive")
			raise Exception("All parameters must be positive")
		elif r2 < r1:
			messagebox.showerror("Error","r2 must be greater than r1")
			raise Exception("r2 must be greater than r1")
		elif dr > r2-r1:
			messagebox.showerror("Error","dr must be less than r2 - r1")
			raise Exception("dr must be less than r2 - r1")
		elif dTheta > angle:
			messagebox.showerror("Error","dθ must be less than θ")
			raise Exception("dθ must be less than θ")

		nr = int((r2-r1)/dr) + 1
		nTheta = int(angle/dTheta) + 1

		def x(r,theta):
			return r * np.cos(theta)
		def y(r,theta):
			return r * np.sin(theta)

		physicalNames = { "Body":2, "Top":1, "Bottom":1, "InWall":1, "OutWall":1 }
		nodes = [ ( x(r,theta), y(r,theta), 0.0 ) for theta in np.linspace(0,angle,nTheta) for r in np.linspace(r1,r2,nr) ]

		elements = []
		elements += [[len(elements)+i+1, *(1, 2), *(2, 2), *(vIdx+1,vIdx+2)] for i, vIdx in enumerate( range(nr*(nTheta-1), nr*nTheta-1) )]
		elements += [[len(elements)+i+1, *(1, 2), *(3, 3), *(vIdx+1,vIdx+2)] for i, vIdx in enumerate( range(0, nr-1) )]
		elements += [[len(elements)+i+1, *(1, 2), *(4, 4), *(vIdx+1,vIdx+nr+1)] for i, vIdx in enumerate( range(0, nr*(nTheta-1), nr) )]
		elements += [[len(elements)+i+1, *(1, 2), *(5, 5), *(vIdx+1,vIdx+nr+1)] for i, vIdx in enumerate( range(nr-1, nr*nTheta-1, nr) )]
		elements += [[len(elements)+i+1, *(3, 2), *(1, 1), *(vIdx+1, vIdx+2, vIdx+2+nr, vIdx+1+nr)] for i, vIdx in enumerate( [ vIdx for vIdx in range(nr*nTheta-nr-1) if (vIdx+1)%nr!=0 ] )]


		text = ""
		text += "$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$PhysicalNames\n"
		text += str( len(physicalNames) ) + "\n"
		text += "".join([ "{} {} \"{}\"\n".format(physicalNames[name], idx+1, name) for idx, name in enumerate(physicalNames.keys()) ])
		text += "$EndPhysicalNames\n$Nodes\n"
		text += str( len(nodes) ) + "\n"
		text += "".join([ "{} {} {} {}\n".format(idx+1, x, y, z) for idx,(x,y,z) in enumerate(nodes) ])
		text += "$EndNodes\n$Elements\n"
		text += str( len(elements) ) + "\n"
		text += "\n".join([" ".join([str(ev) for ev in e]) for e in elements])
		text += "\n$EndElements\n"

		with open(outputPath, "w") as f:
			f.write(text)

	def writePolygon(self):
		X, Y = zip(*self.coordinates)
		dx = float( self.dxEntry.get() )
		dy = float( self.dyEntry.get() )
		outputPath = self.tempPath

		def belongsToPolygon(x, y, X, Y):
			numberOfCorners = len(X)
			oddNodes=False
			for i in range(numberOfCorners):
				verticalLine = abs(Y[i]-Y[i-1]) < 1e-10
				horizontalLine = abs(X[i]-X[i-1]) < 1e-10
				inBetweenX = min(X[i],X[i-1]) <= x <= max(X[i],X[i-1])
				inBetweenY = min(Y[i],Y[i-1]) <= y <= max(Y[i],Y[i-1])
				if verticalLine and abs(Y[i-1]-y) < 1e-10 and inBetweenX:
					return 2
				if horizontalLine and abs(X[i-1]-x) < 1e-10 and inBetweenY:
					return 2
				if not verticalLine and not horizontalLine and inBetweenX and inBetweenY and abs( X[i]+(y-Y[i])*(X[i-1]-X[i])/(Y[i-1]-Y[i]) - x ) < 1e-10:
					return 2
				
				if (Y[i]< y and Y[i-1]>=y or Y[i-1]< y and Y[i]>=y) and (X[i]<=x or X[i-1]<=x):
					oddNodes = ( oddNodes != bool( X[i]+(y-Y[i])/(Y[i-1]-Y[i])*(X[i-1]-X[i]) < x ) )
			return oddNodes
		def generateMesh(X,Y,dx,dy,boundaryNames,outputPath):
			# Create the Grid
			nx = int( (max(X)-min(X)) / dx ) + 1
			ny = int( (max(Y)-min(Y)) / dy ) + 1
			gridNodes = [(x,y) for y in np.linspace(0,(max(Y)-min(Y)),ny) for x in np.linspace(0,(max(X)-min(X)),nx)]
			gridSquares = [ (vIdx, vIdx+1, vIdx+1+nx, vIdx+nx) for i, vIdx in enumerate([vIdx for vIdx in range(nx*ny-nx-1) if (vIdx+1)%nx!=0]) ]

			# Check which grid nodes are inside the polygon
			gridNodesInMesh = [ int(belongsToPolygon(*node, X, Y)) for node in gridNodes ]
			meshNodes = [node for node, isIn in zip(gridNodes,gridNodesInMesh) if isIn]
			meshNodes = [(round(node[0], 8), round(node[1], 8)) for node in meshNodes]
			gridToMeshDict = { idx:sum( [bool(b) for b in gridNodesInMesh[:idx]] ) for idx, (node, isIn) in enumerate( zip(gridNodes,gridNodesInMesh) ) if isIn }

			# Check which grid squares belong to the polygon, and the ones that pass through its boundaries
			squaresInMesh = []
			squaresCut = []
			squaresCutIntersection = []
			for idx, square in enumerate(gridSquares):
				squareNodesIn = [ node for node in square if gridNodesInMesh[node] ]
				squareNodesInside = [ node for node in square if gridNodesInMesh[node] == 1 ]
				if len(squareNodesIn) == 4:
					squaresInMesh.append(idx)
				elif len(squareNodesIn) >= 1:
					squaresCut.append( idx )
					squaresCutIntersection.append(squareNodesIn)

			# Mesh element connectivities
			mesh2DElements = [[ gridToMeshDict[gridNodeIdx] for gridNodeIdx in gridSquares[squareIdx] ] for squareIdx in squaresInMesh]
			originalOne = mesh2DElements.copy()

			# Create 2D elements near the boundary
			for squareIdx, squareNodesInMesh in zip( squaresCut, squaresCutIntersection ):
				squareNodes = gridSquares[squareIdx]

				squareIntersections = []
				squareIntersectionsLocalIndex = []

				# Compute intersections between the square and the polygon
				for i in range(4):
					# Coordinates of square nodes
					n1, n2 = gridNodes[ squareNodes[i] ], gridNodes[ squareNodes[(i+1)%4] ]
					x1, y1, x2, y2 = n1[0], n1[1], n2[0], n2[1]
					for j in range(len(X)):
						# Coordinates of polygon edge
						nA, nB = ( X[j], Y[j] ), ( X[(j+1)%len(X)], Y[(j+1)%len(X)] )
						xA, yA, xB, yB = nA[0], nA[1], nB[0], nB[1]

						denominator = (x2-x1)*(yB-yA)-(xB-xA)*(y2-y1)
						if denominator != 0.0:
							xi = ((x2*y1-x1*y2)*(xB-xA)-(xB*yA-xA*yB)*(x2-x1))/denominator
							yi = ((x2*y1-x1*y2)*(yB-yA)-(xB*yA-xA*yB)*(y2-y1))/denominator

							if ( min(x1,x2) < xi < max(x1,x2) or min(y1,y2) < yi < max(y1,y2) ) and ( min(xA,xB) <= xi <= max(xA,xB) or min(yA,yB) <= yi <= max(yA,yB) ) :
								if not [1 for sn in gridSquares[squareIdx] if abs(gridNodes[sn][0]-xi)<1e-10 and abs(gridNodes[sn][1]-yi)<1e-10]:
									# Check if intersection has already been counted
									if not [n for n in squareIntersections if abs(n[0]-xi)<1e-10 and abs(n[1]-yi)<1e-10]:
										squareIntersections.append((xi,yi))
										squareIntersectionsLocalIndex.append(i)

				if 3 <= len(squareNodesInMesh)+len(squareIntersections) <= 4:
					poly = []
					totalCount = squareNodeCount = intersectionCount = 0
					while True:
						if squareNodeCount < len(squareNodesInMesh) and gridSquares[squareIdx][totalCount] == squareNodesInMesh[squareNodeCount]:
							poly.append( gridToMeshDict[ squareNodesInMesh[squareNodeCount] ] )
							squareNodeCount += 1

						if intersectionCount < len(squareIntersections) and totalCount == squareIntersectionsLocalIndex[intersectionCount]:
							xi, yi = squareIntersections[intersectionCount]
							nIdx = [ i for i,(xn,yn) in enumerate(meshNodes) if abs(xn-xi)<1e-10 and abs(yn-yi)<1e-10 ]
							if nIdx:
								poly.append( nIdx[0] )						
							else:
								meshNodes.append( (xi,yi) )
								poly.append( len(meshNodes)-1 )
							intersectionCount += 1

						if squareNodeCount >= len(squareNodesInMesh) and intersectionCount >= len(squareIntersections):
							break
						totalCount += 1

					
					valid = True
					for i in range(len(poly)):
						if not belongsToPolygon( 0.5*meshNodes[ poly[i] ][0] + 0.5*meshNodes[ poly[i-1] ][0], 0.5*meshNodes[ poly[i] ][1] + 0.5*meshNodes[ poly[i-1] ][1], X, Y ):
							valid = False
					if valid:
						mesh2DElements.append(poly)


				elif len(squareNodesInMesh)+len(squareIntersections) == 5:
					# Check if there is a boundary vertex inside element.
					squareX, squareY = zip(*[gridNodes[n] for n in squareNodes])
					midpoints = [(x,y) for x,y in zip(X,Y) if min(squareX) < x < max(squareX) and min(squareY) < y < max(squareY)]
					if midpoints:
						midpoint = midpoints[0]
					else:
						midpoint = ( (squareIntersections[0][0]+squareIntersections[1][0])/2, (squareIntersections[0][1]+squareIntersections[1][1])/2 )
					meshNodes.append(midpoint)
					midpointIdx = len(meshNodes)-1

					intersectionIdxs = []
					for i in range(2):
						xi, yi = squareIntersections[i]
						nIdx = [ i for i,(xn,yn) in enumerate(meshNodes) if abs(xn-xi)<1e-10 and abs(yn-yi)<1e-10 ]
						if nIdx:
							intersectionIdxs.append( nIdx[0] )						
						else:
							meshNodes.append( (xi,yi) )
							intersectionIdxs.append( len(meshNodes)-1 )

					if gridSquares[squareIdx][0] != squareNodesInMesh[0]:
						hexa = [midpointIdx, intersectionIdxs[0], *[gridToMeshDict[gridIdx] for gridIdx in squareNodesInMesh], intersectionIdxs[1]]
						mpIdx = 0
					else:
						hexa = []
						squareNodeCount = intersectionCount = 0
						for totalCount in range(4):
							if squareNodeCount < len(squareNodesInMesh) and gridSquares[squareIdx][totalCount] == squareNodesInMesh[squareNodeCount]:
								hexa.append( gridToMeshDict[ squareNodesInMesh[squareNodeCount] ] )
								squareNodeCount += 1
							elif intersectionCount < len(squareIntersections):
								hexa += [ intersectionIdxs[0], midpointIdx, intersectionIdxs[1] ]
								mpIdx = totalCount+1
								intersectionCount += 1

					poly1 = hexa[mpIdx-3:mpIdx+1] if hexa[mpIdx-3:mpIdx+1] else hexa[mpIdx-3:] + hexa[:mpIdx+1]
					poly2 = hexa[mpIdx:mpIdx-2]   if hexa[mpIdx:mpIdx-2]   else hexa[mpIdx:]   + hexa[:mpIdx-2]

					mesh2DElements += [poly1, poly2]

			# Create boundaries elements
			boundaries = []
			for idx, name in enumerate(boundaryNames):
				xA, yA, xB, yB = X[idx], Y[idx], X[(idx+1)%len(X)], Y[(idx+1)%len(X)]
				bNodes = [ idx for idx, node in enumerate(meshNodes) if belongsToPolygon(*node, (xA,xB), (yA,yB)) ]
				bNodes = sorted(bNodes, key=lambda i:meshNodes[i][0])
				boundaries.append(bNodes)

			# Set the elements list in the MSH format
			elements = []
			for boundary, bName in zip(boundaries, boundaryNames):
				bIdx = [bName for idx, bName in enumerate(boundaryNames) if idx==boundaryNames.index(bName)].index(bName)
				elements += [[len(elements)+i+1, *(1, 2), *(bIdx+2, bIdx+2), *( boundary[i]+1, boundary[i+1]+1 )] for i in range(len(boundary)-1) ]
			elements += [[len(elements)+i+1, *(len(element)-1, 2), *(1,1), *[nIdx+1 for nIdx in element]] for i, element in enumerate(mesh2DElements) ]

			# Set the physical names ( which are region and boundaries names )
			physicalNames = {"Body":2}
			physicalNames.update({ bName:1 for bName in boundaryNames })

			# Write MSH file
			text  = "$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$PhysicalNames\n"
			text += str( len(physicalNames) ) + "\n"
			text += "".join([ "{} {} \"{}\"\n".format(physicalNames[name], idx+1, name) for idx, name in enumerate(physicalNames.keys()) ])
			text += "$EndPhysicalNames\n$Nodes\n"
			text += str( len(meshNodes) ) + "\n"
			text += "".join([ "{} {} {} 0.0\n".format(idx+1, x, y) for idx,(x,y) in enumerate(meshNodes) ])
			text += "$EndNodes\n$Elements\n"
			text += str( len(elements) ) + "\n"
			text += "\n".join([" ".join([str(ev) for ev in e]) for e in elements])
			text += "\n$EndElements\n"

			with open(outputPath, "w") as f:
				f.write(text)

		generateMesh(X,Y,dx,dy,self.boundaryNames,outputPath)

	def saveMeshAs(self):
		# Another library was imported because even using os,
		# platform would need to be imported in order to detect
		# whether the os is Unix or Windows

		if os.path.isfile(self.tempPath):
			initialdir = os.path.join( os.path.dirname(__file__), os.path.pardir, "meshes" )
			filePath = tk.filedialog.asksaveasfilename(initialdir=initialdir, defaultextension=".msh", filetypes = (("MSH file", "*.msh"), ("All files", "*")))
			if filePath:
				shutil.copyfile(self.tempPath, filePath)
		else:
			messagebox.showerror("Error", "Mesh has not been generated")

	@staticmethod
	def drawMesh(ax, canvas, path):
		ax.clear()
		grid = Grid( MSHReader(path).getData() )

		for e in grid.elements:
			x,y = zip( *[ vertex.getCoordinates()[:-1] for vertex in e.vertices ] )
			x,y = x+(x[0],), y+(y[0],)
			ax.plot(x,y,color="k")

		plt.setp(ax.xaxis.get_ticklabels(), visible=False) 
		plt.setp(ax.yaxis.get_ticklabels(), visible=False) 

		ax.patch.set_facecolor((240/255,240/255,237/255))
		canvas.draw()

class Simulator:
	def __init__(self, root, application):
		self.root = root
		self.app = application
		self.settings()

	def init(self):
		self.meshFileName = ""
		self.simulated = False
		self.drawn = False
		self.popups = []

		self.populatePage1()
		self.page1.show()

	def populatePage1(self):
		def page1Prev():
			if self.meshFileName:
				self.hideBCFig()
				self.hideBCMesh()
			self.page1.destroy()
			self.app.init()	
		def page1Next():
			self.checkFile()
			self.page1.hide()
			self.hideBCFig()
			self.hideBCMesh()
			self.page2.show()
		

		self.page1 = Page(self.root, height=500, width=600, prevFunc=page1Prev, nextFunc=page1Next)

		self.openFrame = tk.Frame(self.page1)
		self.openFrame.place(relx=0.02, rely=0.02, relheight=0.20-0.02, relwidth=1.00-0.04, anchor="nw")

		openButton = tk.Button(self.openFrame, text="Select Mesh", command=self.askFile)
		openButton.bind('<Return>', lambda e:self.askFile())
		openButton.place(relx=0.5, rely=0.1, relheight=0.50, relwidth=0.25, anchor="n")

		self.BCFrame = tk.LabelFrame(self.page1, text="Boundary Conditions Settings")
		self.BCFrame.place(relx=0.02, rely=0.15+0.02, relheight=0.70-0.02, relwidth=1.00-0.04, anchor="nw")

		def showBoundariesFunc():
			if self.showFigVar.get():
				self.showMeshVar.set(False)
				self.hideBCMesh()
				self.showBCFig()
			else:
				self.hideBCFig()
		def showMeshFunc():
			if self.showMeshVar.get():
				self.showFigVar.set(False)
				self.hideBCFig()
				self.showBCMesh()
			else:
				self.hideBCMesh()

		self.showFigVar = tk.BooleanVar()
		self.showFigVar.set(False)
		self.showFigCheckbox = tk.Checkbutton(self.page1.footerFrame, text="Show Boundaries", variable=self.showFigVar, command=showBoundariesFunc, state="disabled")
		self.showFigCheckbox.place(relx=0.0, rely=0.25, anchor="w")
		self.showMeshVar = tk.BooleanVar()
		self.showMeshVar.set(False)
		self.showMeshCheckbox = tk.Checkbutton(self.page1.footerFrame, text="Show Mesh", variable=self.showMeshVar, command=showMeshFunc, state="disabled")
		self.showMeshCheckbox.place(relx=0.0, rely=0.75, anchor="w")

	def populatePage2(self):
		def page2Prev():
			self.page2.hide()
			self.page1.show()
		def page2Next():
			simulate = True
			if self.simulated:
				if "no" == messagebox.askquestion("Warning", "A simulation has already been calculated. Do you want to calculate another one?"):
					simulate = False
					self.page2.hide()
					if self.app.post.returnToSimulator:
						pass
					else:
						self.app.post.consolePage.show()

					return

			if simulate:
				self.checkPage1Data()
				self.checkPage2Data()
				self.saveAs()
				self.runSimulation()
				self.simulated = True

				self.page2.hide()
				self.app.post.setResultsPath(self.resultsPath)
				self.app.post.setSimulator(self)
				self.app.post.init()

		self.page2 = Page(self.root, height=500, width=600, prevFunc=page2Prev, nextFunc=page2Next)
		# Property Frame

		self.propertyEntries = dict()
		self.propertyUnitVars = dict()
		self.propertiesFrames = []
		self.currentRegion = 0

		numberOfRegions = len(self.meshData.regionsNames)

		def nextRegion():
			if self.currentRegion < numberOfRegions-1:
				self.propertiesFrames[self.currentRegion].place_forget()
				self.propertiesFrames[self.currentRegion+1].place(relx=0.02, rely=0.02, relheight=0.81, relwidth=1.00-0.04, anchor="nw")
				self.currentRegion += 1
		def prevRegion():
			if self.currentRegion > 0:
				self.propertiesFrames[self.currentRegion].place_forget()
				self.propertiesFrames[self.currentRegion-1].place(relx=0.02, rely=0.02, relheight=0.81, relwidth=1.00-0.04, anchor="nw")
				self.currentRegion -= 1
		def insertProperties(materialName):
			currentRegionName = self.meshData.regionsNames[self.currentRegion]
			for propertyName in self.materials[materialName].keys():
				self.propertyEntries[currentRegionName][propertyName].delete( 0, tk.END )
				self.propertyEntries[currentRegionName][propertyName].insert( tk.END, self.materials[materialName][propertyName] )
				self.propertyUnitVars[currentRegionName][propertyName].set(self.propertyUnits[propertyName][0])

		for regionCount, region in enumerate(self.meshData.regionsNames):
			propertiesFrame = tk.LabelFrame(self.page2, text="Material Properties")
			self.propertiesFrames.append(propertiesFrame)
			centerFrame = tk.Frame(propertiesFrame)

			self.propertyEntries[region] = dict()
			self.propertyUnitVars[region] = dict()

			self.regionCountLabel = tk.Label(centerFrame, text=f"{region}\t[{regionCount+1}/{numberOfRegions}]")
			self.regionCountLabel.grid(row=0, column=0, pady=5, sticky="W")

			tk.Label(centerFrame, text="Material Database:").grid(row=0, column=4)
			materialsTable = tk.OptionMenu(centerFrame, tk.StringVar(value="Select Material"), *self.materials.keys(), command=lambda propertyName:insertProperties(propertyName))
			materialsTable.grid(row=0, column=5, sticky="nswe")

			i=1
			for propertyName in self.properties:
				options = self.propertyUnits[propertyName]

				unitVar = tk.StringVar(centerFrame)
				unitVar.set(self.propertyUnits[propertyName][0])

				nameLabel = tk.Label(centerFrame, text=propertyName) # TTK
				nameLabel.grid(row=i, column=0, sticky="W", padx=5)

				valEntry = tk.Entry(centerFrame) # TTK
				valEntry.grid(row=i,column=1)

				unitMenu = tk.OptionMenu(centerFrame, unitVar, *options)
				unitMenu.grid(row=i, column=2, sticky="E")


				self.propertyEntries[region][propertyName] = valEntry
				self.propertyUnitVars[region][propertyName] = unitVar
				i+=1

			prevButton = tk.Button(centerFrame, text="<", command=prevRegion, state="disabled" if numberOfRegions==1 or regionCount==0 else "normal")
			prevButton.bind('<Return>', lambda e:prevRegion())
			prevButton.grid(row=i, column=2, sticky="E")

			nextButton = tk.Button(centerFrame, text=">", command=nextRegion, state="disabled" if numberOfRegions==1 or regionCount==numberOfRegions-1 else "normal")
			nextButton.bind('<Return>', lambda e:nextRegion())
			nextButton.grid(row=i, column=3, sticky="W")

			centerFrame.place(relx=0.02, rely=0.0, anchor="nw")

		self.propertiesFrames[0].place(relx=0.02, rely=0.02, relheight=0.45, relwidth=1.00-0.04, anchor="nw")
		
		# Numerical Frame
		numericalFrame = tk.LabelFrame(self.page2, text="Numerical Settings")

		# Help Button
		if "temperature" in self.fields:
			def spaninfo():
				# This variable indicates whether it was possible to calculate h and alpha.
				# This prevents the "?" button to scream at the user for not filled the 
				# 	entries properly
				gotParameters = False

				regionName = self.meshData.regionsNames[self.currentRegion]
				if not True in [entry.get() == "" for entry in self.propertyEntries[regionName].values()]:
					try:
						h = ( sum([element.volume for element in self.grid.elements])/self.grid.elements.size ) ** (1/self.grid.dimension)

						k = float( self.propertyEntries[regionName]["Conductivity"].get() )
						rho = float( self.propertyEntries[regionName]["Density"].get() )
						cp = float( self.propertyEntries[regionName]["HeatCapacity"].get() )
						
						k   = self.unitsConvert[ self.propertyUnitVars[regionName]["Conductivity"].get() ](k)
						rho = self.unitsConvert[ self.propertyUnitVars[regionName]["Density"].get() ](rho)
						cp  = self.unitsConvert[ self.propertyUnitVars[regionName]["HeatCapacity"].get() ](cp)
						
						alpha = k / (rho * cp)
						
						gotParameters = True
					except: 
						# Note that when expression properties get implemented,
						# this will throw an error here
						print("Properties parameters have not been properly filled yet")

				if gotParameters:
					tk.messagebox.showinfo("Help", f"{regionName} info.\nCharacteristic mesh length (h) = {h:.03e} m\nDiffusivity (α=k/(ρ cp) = {alpha:.03e} m²/s\nParameter for timeStep (h²/α) = {h**2/alpha:.03e} s")
				else:
					tk.messagebox.showinfo("Help", f"Fill in {regionName} properties to see its diffusivity and characteristic mesh length")
			
			infobox = tk.Button(numericalFrame, text="  ?  ", command=spaninfo)
			infobox.place(relx=0.96, rely=0.0, anchor="ne")

		# Numerical Settings
		self.numericalSettingsEntries = []
		self.numericalSettingsUnits = []
		self.numericalSettingsUnitMenus = []
		self.numericalSettingsBools = []
		self.numericalSettingsCheckboxes = []

		def toggleCheckbox(i):
			def toggleCheckboxFunc():
				setting = list(self.numericalSettingsOp.keys())[i]
				state = self.numericalSettingsBools[i].get()

				if setting != "Transient":
					# Entry
					if self.numericalSettingsOp[setting]["option"][0]:
						if state:
							self.numericalSettingsEntries[i].grid(row=i, column=1, padx=5, pady=5, sticky="W")
						else:
							self.numericalSettingsEntries[i].grid_forget()
					# Unit
					if self.numericalSettingsOp[setting]["option"][1]:
						if state:
							self.numericalSettingsUnitMenus[i].grid(row=i, column=2, sticky="E")
						else:
							self.numericalSettingsUnitMenus[i].grid_forget()
				else:
					if state:
						j=0
						for loopSetting, entry, unitMenu, boolVar, checkbox in zip( self.numericalSettingsOp.keys(), self.numericalSettingsEntries, self.numericalSettingsUnitMenus, self.numericalSettingsBools, self.numericalSettingsCheckboxes ):
							if self.numericalSettingsOp[loopSetting]["option"][0] and self.numericalSettingsOp[loopSetting]["option"][3]:
								entry.grid(row=j, column=1, padx=5, pady=5, sticky="W")
							
							if self.numericalSettingsOp[loopSetting]["option"][1] and self.numericalSettingsOp[loopSetting]["option"][3]:
								unitMenu.grid(row=j, column=2, sticky="E")
							boolVar.set(self.numericalSettingsOp[loopSetting]["option"][3])
							if loopSetting != "Time Step":
								checkbox.configure(state="normal")
							j+=1
					else:
						for loopSetting, entry, unitMenu, boolVar, checkbox in zip( self.numericalSettingsOp.keys(), self.numericalSettingsEntries, self.numericalSettingsUnitMenus, self.numericalSettingsBools, self.numericalSettingsCheckboxes ):
							if loopSetting != "Transient":
								entry.grid_forget()
								unitMenu.grid_forget()
								boolVar.set(False)
								checkbox.configure(state="disabled")

			return toggleCheckboxFunc

		i=0
		for setting in self.numericalSettingsOp.keys():
			# Label
			label = tk.Label(numericalFrame, text=setting)
			label.grid(row=i, column=0, padx=5, pady=5, sticky="W")

			# Entry
			entry = tk.Entry(numericalFrame)
			if self.numericalSettingsOp[setting]["option"][0] and self.numericalSettingsOp[setting]["option"][3]:
				entry.grid(row=i, column=1, padx=5, pady=5, sticky="W")

			self.numericalSettingsEntries.append(entry)

			# Unit
			unitVar = tk.StringVar(numericalFrame)
			unitVar.set(self.numericalSettingsOp[setting]["units"][0])

			unitMenu = tk.OptionMenu(numericalFrame, unitVar, *self.numericalSettingsOp[setting]["units"])
			if self.numericalSettingsOp[setting]["option"][1] and self.numericalSettingsOp[setting]["option"][3]:
				unitMenu.grid(row=i, column=2, sticky="E")

			self.numericalSettingsUnits.append(unitVar)
			self.numericalSettingsUnitMenus.append(unitMenu)

			# Checkbox
			boolVar = tk.BooleanVar()
			boolVar.set(self.numericalSettingsOp[setting]["option"][3])

			checkbox = tk.Checkbutton(numericalFrame, variable=boolVar, command=toggleCheckbox(i), state= "normal" if self.numericalSettingsOp[setting]["option"][2] else "disabled")
			checkbox.grid(row=i, column=3)

			self.numericalSettingsBools.append(boolVar)
			self.numericalSettingsCheckboxes.append(checkbox)

			i+=1

		numericalFrame.place(relx=0.02, rely=0.45+0.02, relheight=0.40-0.02, relwidth=1.00-0.04, anchor="nw")

		self.populated = True      
  
	def populateBCFrame(self):
		self.boundariesNames = self.meshData.boundariesNames
		self.currentField = 0
		fieldsBCCanvas = []
		fieldsIValueFrames = []
		fieldsBCWindows = dict()

		self.boundaryUnitVars		= dict()
		self.boundaryTypeVars		= dict()
		self.boundaryValueEntries	= dict()
		self.boundaryUnitMenus		= dict()

		self.initialValueEntries	= dict()
		self.initialValueUnitVars	= dict()

		def chooseNeumannRadioButton(i, field): #
			def chooseNeumannRadioButtonFunc():
				unitVar = self.boundaryUnitVars[field][i]
				optionMenu = self.boundaryUnitMenus[field][i]

				unitVar.set("")
				optionMenu["menu"].delete(0,"end") # remove full list 
				for opt in self.neumannUnits[field]: 
					optionMenu['menu'].add_command(label=opt, command=tk._setit(unitVar, opt))
				unitVar.set(self.neumannUnits[field][0]) # default value set 

			return chooseNeumannRadioButtonFunc
		def chooseDirichletRadioButton(i, field): #
			def chooseDirichletRadioButtonFunc():
				unitVar = self.boundaryUnitVars[field][i]
				optionMenu = self.boundaryUnitMenus[field][i]

				unitVar.set("")
				optionMenu["menu"].delete(0,"end") # remove full list 
				for opt in self.dirichletUnits[field]: 
					optionMenu['menu'].add_command(label=opt, command=tk._setit(unitVar, opt))
				unitVar.set(self.dirichletUnits[field][0]) # default value set 
			return chooseDirichletRadioButtonFunc
		def prevField():
			if self.currentField > 0:
				fieldsBCCanvas[self.currentField].place_forget()
				fieldsIValueFrames[self.currentField].place_forget()
				self.currentField -= 1
				fieldsBCCanvas[self.currentField].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
				fieldsIValueFrames[self.currentField].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
				self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))
		def nextField():
			if self.currentField < len(self.fields)-1:
				fieldsBCCanvas[self.currentField].place_forget()
				fieldsIValueFrames[self.currentField].place_forget()
				self.currentField += 1
				fieldsBCCanvas[self.currentField].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
				fieldsIValueFrames[self.currentField].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
				self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))
		def placeStatic(field):
			BCCanvas = tk.Canvas(self.BCFrame)
			fieldsBCCanvas.append(BCCanvas)

			scrollbar = ttk.Scrollbar(self.BCFrame, orient="vertical", command=BCCanvas.yview) # TTK
			scrollbar.place(relx=1.0, rely=0.0, relheight=0.85, anchor="ne")

			# with Windows OS
			self.root.bind("<MouseWheel>", lambda e: BCCanvas.yview_scroll(-1*int(e.delta/120), "units"))
			# with Linux OS
			self.root.bind("<Button-4>", lambda e: BCCanvas.yview_scroll(-1, "units"))
			self.root.bind("<Button-5>", lambda e: BCCanvas.yview_scroll(+1, "units"))

			BCWindow = ttk.Frame(BCCanvas) # TTK
			BCWindow.bind("<Configure>", lambda event: BCCanvas.configure(scrollregion=BCCanvas.bbox("all")))

			BCCanvas.create_window((0, 0), window=BCWindow, anchor="nw")
			BCCanvas.configure(yscrollcommand=scrollbar.set)

			BCWindow.columnconfigure(index=0, pad=5)
			BCWindow.columnconfigure(index=1, pad=5)
			BCWindow.columnconfigure(index=2, pad=5)
			BCWindow.columnconfigure(index=3, pad=5)
			BCWindow.rowconfigure(index=0, pad=5)
			BCWindow.rowconfigure(index=1, pad=5)
			BCWindow.rowconfigure(index=2, pad=5)
			BCWindow.rowconfigure(index=3, pad=5)

			tk.Label(BCWindow, text="Boundary Name").grid(row=0, column=0) # TTK
			tk.Label(BCWindow, text="Value").grid(row=0, column=1) # TTK
			tk.Label(BCWindow, text="Unit").grid(row=0, column=2) # TTK
			tk.Label(BCWindow, text="  Neumann BC  ").grid(row=0, column=3) # TTK
			tk.Label(BCWindow, text="  Dirichlet BC  ").grid(row=0, column=4) # TTK
			
			fieldsBCWindows[field] = BCWindow
		def placeInputs(field):
			# Obs.: If 3D then neumann units are [Temp]/[Distance^2]
			BCWindow = fieldsBCWindows[field]
			self.boundaryUnitVars[field]		  = []
			self.boundaryTypeVars[field]		  = []
			self.boundaryValueEntries[field]	  = []
			self.boundaryUnitMenus[field]		  = []

			i=1
			for boundaryName in self.boundariesNames:
				options = []

				unitVar = tk.StringVar(BCWindow)
				unitVar.set("")
				bTypeVar = tk.IntVar(BCWindow)

				nameLabel = tk.Label(BCWindow, text=boundaryName) # TTK
				nameLabel.grid(row=i, column=0, padx=5, sticky="W")

				unitMenu = ttk.OptionMenu(BCWindow, unitVar, *options) # TTK
				unitMenu.grid(row=i, column=2, sticky="E")

				neumannButton = tk.Radiobutton(BCWindow, variable=bTypeVar, value=1, command=chooseNeumannRadioButton(i-1, field))
				neumannButton.grid(row=i, column=3)

				dirichletButton = tk.Radiobutton(BCWindow, variable=bTypeVar, value=2, command=chooseDirichletRadioButton(i-1, field))
				dirichletButton.grid(row=i, column=4)

				self.boundaryUnitVars[field].append(unitVar)
				self.boundaryTypeVars[field].append(bTypeVar)
				self.boundaryUnitMenus[field].append(unitMenu)

				i+=1
			i=1
			for boundaryName in self.boundariesNames:
				valEntry = tk.Entry(BCWindow)
				valEntry.grid(row=i,column=1)
				self.boundaryValueEntries[field].append(valEntry)

				i+=1
		def placeInitialValue(field):
			initialValueFrame = tk.LabelFrame(self.BCFrame)
			fieldsIValueFrames.append(initialValueFrame)

			initialValueLabel = tk.Label(initialValueFrame, text="Frame's\ninitial value")

			self.initialValueEntries[field] = tk.Entry(initialValueFrame)

			self.initialValueUnitVars[field] = tk.StringVar(initialValueFrame)
			self.initialValueUnitVars[field].set("")

			unitMenu = ttk.OptionMenu(initialValueFrame, self.initialValueUnitVars[field], *self.dirichletUnits[field]) # TTK

			if self.initialValuesNeeded:
				initialValueLabel.place(relx=0.0, rely=0.5, anchor="w")
				self.initialValueEntries[field].place(x=100, rely=0.5, anchor="w")
				unitMenu.place(x=270, rely=0.5, anchor="w")


			prevButton = tk.Button(initialValueFrame, text="  <  ", command=prevField, state="disabled" if field == self.fields[0] else "normal")
			prevButton.bind('<Return>', lambda e:prevField())
			prevButton.place(relx=0.9, rely=0.5, anchor="e")

			nextButton = tk.Button(initialValueFrame, text="  >  ", command=nextField, state="disabled" if field == self.fields[-1] else "normal")
			nextButton.bind('<Return>', lambda e:nextField())
			nextButton.place(relx=0.9, rely=0.5, anchor="w")

		for field in self.fields:
			placeStatic(field)
			placeInputs(field)
			placeInitialValue(field)

		fieldsBCCanvas[0].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
		fieldsIValueFrames[0].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
		self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))

	def populateBCFig(self):
		self.drawn = True
		self.figDrawCanvas = tk.Canvas(self.root, width=600, height=500)

		figure = matplotlib.figure.Figure()
		plot = figure.add_subplot()

		i=0
		for boundary, boundaryName in zip(self.meshData.boundariesIndexes, self.meshData.boundariesNames):
			boundaryColor = plt.cm.get_cmap("hsv", len(self.meshData.boundariesNames)+1)(i)
			for facet in boundary:
				pair = self.meshData.boundariesConnectivities[facet]
				coords = [self.meshData.vertices[v][:-1] for v in pair]
				plot.plot(*zip(*coords), color=boundaryColor, label=boundaryName if facet==boundary[0] else None)

			i+=1
		plot.legend()
		canvas = FigureCanvasTkAgg(figure, self.figDrawCanvas)
		canvas.get_tk_widget().pack(side="left", fill="both", expand=1)

	def populateBCMesh(self):
		self.drawn = True
		self.meshDrawCanvas = tk.Canvas(self.root, width=600, height=500)

		figure = matplotlib.figure.Figure()
		plot = figure.add_subplot()

		for element in self.meshData.elementsConnectivities:
			x,y,z = zip(*[self.meshData.vertices[vertexIdx] for vertexIdx in element+[element[0]] ])
			plot.plot(x,y,color="k")

		canvas = FigureCanvasTkAgg(figure, self.meshDrawCanvas)
		canvas.get_tk_widget().pack(side="left", fill="both", expand=1)

	def showBCFig(self):
		self.figDrawCanvas.pack(side="left", fill="both", expand=1)

	def showBCMesh(self):
		self.meshDrawCanvas.pack(side="left", fill="both", expand=1)

	def hideBCFig(self):
		self.figDrawCanvas.pack_forget()

	def hideBCMesh(self):
		self.meshDrawCanvas.pack_forget()

	def askFile(self):
		[ popup.destroy() for popup in self.popups ]
		self.popups = []

		if self.meshFileName:
			self.hideBCFig()
			self.hideBCMesh()
		askMeshWin = tk.Toplevel()
		askMeshWin.geometry("{}x{}".format(500,100))
		askMeshWin.title("Select Mesh Option")
		self.popups.append(askMeshWin)

		askMeshFrame = tk.Frame(askMeshWin)
		askMeshFrame.pack()

		def selectFileCommand():
			askMeshWin.destroy()
			self.openFile()
			if self.meshFileName:
				self.readFile(self.meshFileName)
		def preGeoCommand():
			self.app.geoMesh.setSimulator(self)
			askMeshWin.destroy()
			self.app.geoMesh.initPre()
		def contourCommand():
			self.app.geoMesh.setSimulator(self)
			askMeshWin.destroy()
			self.app.geoMesh.initContour()

		tk.Button(askMeshFrame, height=4, text="Select Mesh File", command=selectFileCommand).grid(column=0, row=0, padx=5, pady=5)
		tk.Button(askMeshFrame, height=4, text="Create mesh from\npredetermined geometry", command=preGeoCommand).grid(column=1, row=0, padx=5, pady=5)
		tk.Button(askMeshFrame, height=4, text="Create mesh from\ncontour points", command=contourCommand).grid(column=2, row=0, padx=5, pady=5)

	def openFile(self):
		initialdir = os.path.join( os.path.dirname(__file__), os.path.pardir, "meshes" )
		prevMeshFileName = self.meshFileName
		self.meshFileName = tk.filedialog.askopenfilename(initialdir=initialdir, title="Select a mesh file", filetypes=(("MSH files", "*.msh"),("All files", "*")))
		if self.meshFileName: # Prevents against not choosing a file
			if not ".msh" in self.meshFileName:
				# Prevents from forgetting already selected mesh if select mesh button is accidentally pressed
				self.meshFileName = prevMeshFileName
				tk.messagebox.showwarning("Warning","Must be a .msh file")
				raise Exception("Must be a .msh file")
			try:
				MSHReader(self.meshFileName).getData()
			except:
				# Prevents from forgetting already selected mesh if select mesh button is accidentally pressed
				self.meshFileName = prevMeshFileName
				tk.messagebox.showwarning("Warning","Invalid mesh file")
				raise Exception("Invalid mesh file")
		else:
			self.meshFileName = prevMeshFileName

	def readFile(self, fileName):
		self.meshFileName = fileName
		self.meshData = MSHReader(self.meshFileName).getData()
		self.grid = Grid( self.meshData )
		if self.grid.dimension == 2:
			if self.drawn:
				self.figDrawCanvas.destroy()
			self.showFigCheckbox.configure(state="normal")
			self.showMeshCheckbox.configure(state="normal")
			self.populateBCFig()
			self.populateBCMesh()

		self.root.title("PyEFVLib GUI - {}".format(self.meshFileName))
		self.populateBCFrame()
		self.populatePage2()

	def saveAs(self):
		initialdir = os.path.join( os.path.dirname(__file__), os.path.pardir, "results", "gui" )
		self.resultsPath = tk.filedialog.asksaveasfilename(initialdir=initialdir, defaultextension=".csv", filetypes = (("CSV file", "*.csv"), ("All files", "*")))

		sepIdx = self.resultsPath[::-1].index("/")
		self.outputFilePath = self.resultsPath[-sepIdx:].replace(".csv", "")
		self.outputDir = self.resultsPath[:-sepIdx]

	def checkFile(self):
		if not self.meshFileName:
			tk.messagebox.showwarning("Warning","Must Select a mesh File")
			raise Exception("Must select a mesh file")

	def checkPage1Data(self):
		for field in self.fields:
			for boundaryName, entry, bType in zip(self.boundariesNames, self.boundaryValueEntries[field], self.boundaryTypeVars[field]):
				BCExpression = entry.get()
				try:
					float( BCExpression )
				except:
					try:
						# Try to parse expression
						getFunction( BCExpression )( *np.random.rand((4)) )
					except:
						tk.messagebox.showwarning("Warning","Invalid value in \"{} - {}\" field".format(field, boundaryName))
						raise Exception("Invalid value in \"{} - {}\" field".format(field, boundaryName))
				if bType.get() == 0:
					tk.messagebox.showwarning("Warning","Must select either Neumann or Dirichlet Boundary Condition")
					raise Exception("Must select either Neumann or Dirichlet Boundary Condition")
			initialExpression = self.initialValueEntries[field].get()
			if not self.initialValuesNeeded:
				initialExpression = "0.0"
			try:
				float( initialExpression )
			except:
				try:
					# Try to parse expression
					# Variable initial expression not implemented yet
					getFunction( initialExpression )( *np.random.rand((4)) )
				except:
					tk.messagebox.showwarning("Warning", "Invalid value in Initial Value field")
					raise Exception("Invalid value in Initial Value field")
	
	def checkPage2Data(self):
		for region in self.meshData.regionsNames:
			for propertyName in self.properties:
					propertyValue = self.propertyEntries[region][propertyName].get()
					try:
						float( propertyValue )
					except:
						tk.messagebox.showwarning("Warning", "Invalid value in \"{}\" {} field".format(region, propertyName))
						raise Exception("Invalid value in \"{}\" {} field".format(region, propertyName))
	
		transientIndex = list(self.numericalSettingsOp.keys()).index("Transient")
		finalTimeIndex = list(self.numericalSettingsOp.keys()).index("Final time")
		numberOfTSIndex = list(self.numericalSettingsOp.keys()).index("Max number of time steps")
		toleranceIndex = list(self.numericalSettingsOp.keys()).index("Tolerance")
		
		if self.numericalSettingsBools[transientIndex].get():
			if not self.numericalSettingsBools[finalTimeIndex].get() and not self.numericalSettingsBools[numberOfTSIndex].get() and not self.numericalSettingsBools[toleranceIndex].get():
				tk.messagebox.showwarning("Warning", "There is no way of reaching convergence. Set at least one of final time, max number of iterations or tolerance fields")
				raise Exception("There is no way of reaching convergence. Set at least one of final time, max number of iterations or tolerance fields")

		i=0
		for numericalSetting in self.numericalSettingsOp.keys():
			if self.numericalSettingsOp[numericalSetting]["option"][0] and self.numericalSettingsBools[i].get():
				try:
					float( self.numericalSettingsEntries[i].get() )
					if float( self.numericalSettingsEntries[i].get() ) <= 0.0:
						self.numericalSettingsEntries[i].delete( 0, tk.END )
						raise Exception("Warning", "Numerical settings must be positive")
				except:
					tk.messagebox.showwarning("Warning", "Invalid input in {} field".format(numericalSetting))
					raise Exception("Invalid input in {} field".format(numericalSetting))
			i+=1

	def quit(self):
		self.root.destroy()

class SolidMechanicsSimulator(Simulator):
	def settings(self):
		self.fields = ["u", "v"]
		self.initialValuesNeeded = False

		self.neumannUnits = {"u": ["Pa", "kPa", "MPa", "GPa", "kgf/m²", "psi"], "v": ["Pa", "kPa", "MPa", "GPa", "kgf/m²", "psi"]}
		self.dirichletUnits = {"u": ["m", "mm", "cm", "μm", "inch"], "v": ["m", "mm", "cm", "μm", "inch"]}

		self.properties = ["Density", "PoissonsRatio", "ShearModulus", "Gravity"]
		self.propertyUnits = {
			"Density"		: ["kg/m³", "g/cm³"], 		
			"PoissonsRatio" : [""], 
			"ShearModulus"	: ["MPa", "GPa", "kPa", "Pa", "psi"], 
			"Gravity"		: ["m/s²", "mm/s²", "km/h²"]

		}

		self.numericalSettingsOp = {	# "option": [entry, unit, checkbox]
			"Time Step"					:{"option":[1,1,0,0],"units":["s", "min", "h", "days", "weeks"]},
			"Final time"				:{"option":[1,1,0,0],"units":["s", "min", "h", "days", "weeks"]},
			"Max number of time steps"	:{"option":[1,0,0,0],"units":[""]},
			"Tolerance"					:{"option":[1,1,0,0],"units":["K"]},
			"Transient"					:{"option":[0,0,0,0],"units":[""]}
		}

		self.unitsConvert = {
			"m"		: lambda x: x,
			"mm"		: lambda x: 0.001*x,
			"cm"		: lambda x: 0.01*x,
			"μm"		: lambda x: 1e-06*x,
			"inch"		: lambda x: 0.0254*x,
			"kg/m³"		: lambda rho: rho,
			"g/cm³"		: lambda rho: 1000.0*rho,
			""			: lambda _: _,
			"MPa"		: lambda P: 1e+06*P,
			"kgf/m²"	: lambda P: 9.807*P,
			"GPa"		: lambda P: 1e+09*P,
			"kPa"		: lambda P: 1e+03*P,
			"Pa"		: lambda P: P,
			"psi"		: lambda P: 6894.757*P,
			"m/s²"		: lambda a: a,
			"mm/s²"		: lambda a: 0.001*a,
			"km/h²"		: lambda a: 7.716e-05*a,
			"s"			: lambda t: t,
			"min"		: lambda t: 60.0*t,
			"h"			: lambda t: 3600*t,
			"days"		: lambda t: 86400.0*t,
			"weeks"		: lambda t: 604800.0*t,
		}

		self.materials = {
			"Select material": { "Density": "", "PoissonsRatio": "", "ShearModulus": "", "Gravity": "" },
			"Material 01": { "Density": 2400, "PoissonsRatio": 0.33, "ShearModulus": 6.0, "Gravity": -9.81 },

		}

	def runSimulation(self):
		if self.grid.dimension != 2:
			tk.messagebox.showwarning("Warning","Stress Equilibrium Problem not implemented yet for 3D cases")
			self.quit()
			raise Exception("Stress Equilibrium Problem not implemented yet for 3D cases")

		# Boundary Conditions
		
		neumannBoundaries = dict()
		dirichletBoundaries = dict()
		boundaryConditionsDict = {bName : dict() for bName in self.boundariesNames}

		for field in self.fields:
			neumannBoundaries[field] = []
			dirichletBoundaries[field] = []
			handle = 0

			for bName, boundary, entry, unit, bType in zip(self.boundariesNames, self.grid.boundaries, self.boundaryValueEntries[field], self.boundaryUnitVars[field], self.boundaryTypeVars[field]):
				convertFunc = self.unitsConvert[unit.get()]
				value = entry.get()
				try:
					value = convertFunc( float(value) )
					expression = False
				except:
					expression = True

				if bType.get() == 1:
					bc = NeumannBoundaryCondition(self.grid, boundary, value, handle)
					bc.expression = expression
					bc.function = getFunction( value, convertFunc )
					neumannBoundaries[field].append(bc)
				if bType.get() == 2:
					bc = DirichletBoundaryCondition(self.grid, boundary, value, handle)
					bc.expression = expression
					bc.function = getFunction( value, convertFunc )
					dirichletBoundaries[field].append(bc)
				boundaryConditionsDict[bName][field] = bc
				handle += 1

		# Property Data
		self.propertyData = []
		for region in self.grid.regions:
			self.propertyData.append( dict() )
			for propertyName in self.propertyEntries[region.name].keys():
				self.propertyData[-1][propertyName] = float( self.propertyEntries[region.name][propertyName].get() )
				self.propertyData[-1][propertyName] = self.unitsConvert[ self.propertyUnitVars[region.name][propertyName].get() ]( self.propertyData[-1][propertyName] )


		solver = stressEquilibrium("workspace/stress_equilibrium_2d/linear", solve=False)

		solver.gravity = True
		solver.problemData.libraryPath = os.path.join(os.path.dirname(__file__), os.path.pardir)
		solver.problemData.paths["Output"] = self.outputDir
		solver.outputFileName = self.outputFilePath
		solver.extension = "csv"
		
		solver.grid = self.grid
		solver.problemData.propertyData = self.propertyData

		solver.problemData.neumannBoundaries = neumannBoundaries
		solver.problemData.dirichletBoundaries = dirichletBoundaries
		solver.problemData.boundaryConditions = list(boundaryConditionsDict.values())

		solver.solve()

		self.app.post.returnToSimulator = True

class HeatTransferSimulator(Simulator):
	def settings(self):
		self.fields = ["temperature"]
		self.initialValuesNeeded = True

		self.neumannUnits = {"temperature": ["K/m"]}
		self.dirichletUnits = {"temperature": ["K", "°C", "°F"]}
		
		self.properties = ["Density","HeatCapacity","Conductivity","HeatGeneration"]
		self.propertyUnits = {
			"Density":        ["kg/m³", "g/cm³"],
			"HeatCapacity":   ["J/kg.K"],
			"Conductivity":   ["W/m.K"],
			"HeatGeneration": ["K/m³"]
		}

		self.numericalSettingsOp = {	# "option": [entry, unit, checkbox]
			"Time Step"					:{"option":[1,1,0,1],"units":["s", "min", "h", "days", "weeks"]},
			"Final time"				:{"option":[1,1,1,0],"units":["s", "min", "h", "days", "weeks"]},
			"Max number of time steps"	:{"option":[1,0,1,1],"units":[""]},
			"Tolerance"					:{"option":[1,1,1,0],"units":["K"]},
			"Transient"					:{"option":[0,0,1,1],"units":[""]}
		}

		self.unitsConvert = {
			"K"		: lambda T: T,
			"°C"	: lambda T: T+273.15,
			"°F"	: lambda T: 5.0*(T-32.0)/9.0+273.15,
			"K/m"	: lambda d: d,
			"kg/m³"	: lambda rho: rho,
			"g/cm³"	: lambda rho: 1000.0*rho,
			"J/kg.K": lambda Cp: Cp,
			"W/m.K"	: lambda k: k,
			"K/m³"	: lambda q: q,
			"s"		: lambda t: t,
			"min"	: lambda t: 60.0*t,
			"h"		: lambda t: 3600*t,
			"days"	: lambda t: 86400.0*t,
			"weeks"	: lambda t: 604800.0*t,
		}

		self.materials = {
			"Select material": { "Density": "", "HeatCapacity": "", "Conductivity": "", "HeatGeneration": "" },
			"Material 01": { "Density": 1200, "HeatCapacity": 300, "Conductivity": 30, "HeatGeneration": 0.0 },

		}

	def runSimulation(self):
		convertFunc = self.unitsConvert[ self.initialValueUnitVars["temperature"].get() ]
		initialValue = self.initialValueEntries["temperature"].get()
		try:
			initialValue = float(initialValue)
			initialValueFunc = lambda x,y,z:convertFunc(initialValue)
		except:
			initialValueFunc = getFunction(initialValue, convertFunc)

		initialValues = {"temperature": [initialValueFunc( *v.getCoordinates() ) for v in self.grid.vertices]}

		# Boundaries
		neumannBoundaries = { "temperature": [] }
		dirichletBoundaries = { "temperature": [] }
		handle = 0
		for bName, boundary, entry, unit, condition in zip(self.boundariesNames,self.grid.boundaries,self.boundaryValueEntries["temperature"],self.boundaryUnitVars["temperature"],self.boundaryTypeVars["temperature"] ):
			conversionFunc = self.unitsConvert[unit.get()]
			condition = ["NEUMANN", "DIRICHLET"][condition.get()-1]
			
			try:
				value = conversionFunc( float( entry.get() ) )
				expression = False
			except:
				value = entry.get()
				expression = True

			boundaryCondition = BoundaryCondition(self.grid, boundary, value, handle)
			boundaryCondition.__type__   = condition
			boundaryCondition.expression = expression
			boundaryCondition.function   = getFunction( value, conversion=conversionFunc )

			if condition == "NEUMANN":
				neumannBoundaries["temperature"].append(boundaryCondition)
			elif condition == "DIRICHLET":
				dirichletBoundaries["temperature"].append(boundaryCondition)

			handle += 1

		# Property Data
		self.propertyData = []
		for region in self.grid.regions:
			self.propertyData.append( dict() )
			for propertyName in self.propertyEntries[region.name].keys():
				self.propertyData[-1][propertyName] = float( self.propertyEntries[region.name][propertyName].get() )
				self.propertyData[-1][propertyName] = self.unitsConvert[ self.propertyUnitVars[region.name][propertyName].get() ]( self.propertyData[-1][propertyName] )

		# Numerical Settings
		index = list(self.numericalSettingsOp.keys()).index("Time Step")
		if self.numericalSettingsBools[index].get():
			timeStep  = float(self.numericalSettingsEntries[index].get())
			timeStep  = self.unitsConvert[ self.numericalSettingsUnits[index].get() ](timeStep) 
		else:
			timeStep = 0.0

		index = list(self.numericalSettingsOp.keys()).index("Final time")
		if self.numericalSettingsBools[index].get():
			finalTime = float(self.numericalSettingsEntries[index].get())
			finalTime  = self.unitsConvert[ self.numericalSettingsUnits[index].get() ](finalTime) 
		else:
			finalTime = None

		index = list(self.numericalSettingsOp.keys()).index("Max number of time steps")
		if self.numericalSettingsBools[index].get():
			maxNumberOfTimeSteps = float(self.numericalSettingsEntries[index].get())
		else:
			maxNumberOfTimeSteps = None

		index = list(self.numericalSettingsOp.keys()).index("Tolerance")
		if self.numericalSettingsBools[index].get():
			tolerance = float(self.numericalSettingsEntries[index].get())
		else:
			tolerance = None

		transient = self.numericalSettingsBools[list(self.numericalSettingsOp.keys()).index("Transient")].get()


		solver = heatTransfer("workspace/heat_transfer_2d/linear", solve=False)

		solver.problemData.libraryPath = os.path.join(os.path.dirname(__file__), os.path.pardir)
		solver.problemData.paths["Output"] = self.outputDir
		solver.outputFileName = self.outputFilePath
		solver.extension = "csv"
		
		solver.grid = self.grid
		solver.problemData.propertyData = self.propertyData

		solver.problemData.initialValues = initialValues
		solver.problemData.neumannBoundaries = neumannBoundaries
		solver.problemData.dirichletBoundaries = dirichletBoundaries

		solver.problemData.timeStep  = timeStep 
		solver.problemData.finalTime = finalTime
		solver.problemData.maxNumberOfIterations = maxNumberOfTimeSteps
		solver.problemData.tolerance = tolerance
		
		solver.transient = transient
		solver.verbosity = True

		f = io.StringIO()		
		with redirect_stdout(f):
			solver.solve()

		self.app.post.setOutputTextVar(f)

class Post:
	def __init__(self, root, application):
		self.root = root
		self.app = application
		self.settings()

	def settings(self):
		self.first = True
		self.consoleTextSet = False
		self.returnToSimulator = False

	def init(self):
		self.readData()
		self.populateConsole()
		self.populatePage1()
		self.populatePage2()

		if self.consoleTextSet:
			self.consolePage.show()
		else:
			self.page1.show()

	def populateConsole(self):
		def prevFunc():
			self.consolePage.hide()
			self.simulator.page2.show()
		def nextFunc():
			self.consolePage.hide()
			self.page1.show()

		self.consolePage = Page(self.root, width=600, height=500, prevFunc=prevFunc, nextFunc=nextFunc)

		tk.Label(self.consolePage, text="Console:").place(relx=0.02, rely=0.02, anchor="nw")

		if self.consoleTextSet:
			outputText = scrolledtext.ScrolledText(self.consolePage)
			outputText.insert(tk.END, self.outputTextVar.getvalue())
			outputText.configure(state="disabled")
			outputText.place(relx=0.02, rely=0.02+0.05, relheight=0.80, relwidth=1.00-0.04, anchor="nw" )

	def populatePage1(self):
		self.page1 = Page(self.root, width=600, height=500, prevFunc=self.page1Prev,nextFunc=self.page1Next)
		# Settings
		def changeTSStringVar():
			self.timeStepStrVar.set( self.timeSteps[ self.timeStepVar.get()-1 ] )
		def slideTSIntVar(value):
			self.timeStepVar.set( round(float( value )) )
			changeTSStringVar()

		self.CMSettingsFrame = tk.LabelFrame(self.page1, text="Colormap Settings")

		centerFrame = tk.Frame(self.CMSettingsFrame)

		timeStepLabel = tk.Label(centerFrame, text="Time Step:")
		timeStepLabel.grid(row=0, column=0, padx=5, pady=5, sticky="w")

		self.timeStepVar = tk.IntVar(value=self.numberOfTimeSteps)
		
		timeStepBox = tk.Spinbox(centerFrame, textvariable=self.timeStepVar, from_=1, to=self.numberOfTimeSteps, width=5, state="readonly" if self.numberOfTimeSteps > 1 else "disabled")
		timeStepBox.grid(row=0, column=2, pady=5)

		timeStepSlider = ttk.Scale(centerFrame, from_=1, to=self.numberOfTimeSteps, orient="horizontal", variable=self.timeStepVar, command=slideTSIntVar) # TTK
		timeStepSlider.grid(row=0, column=1, padx=5, pady=5)

		maxTimeStepLabel = tk.Label(centerFrame, text=f"/{self.numberOfTimeSteps}")
		maxTimeStepLabel.grid(row=0, column=3, pady=5)

		tk.Label(centerFrame).grid(row=1, column=3, padx=5)
		showButton = tk.Button(centerFrame, text="Show", command=self.showColorMap)
		showButton.bind('<Return>', lambda e:self.showColorMap())
		showButton.grid(row=0, column=4, padx=5, pady=5, sticky="e")

		fieldLabel = tk.Label(centerFrame, text="Field:")
		fieldLabel.grid(row=1, column=0, padx=5, pady=5, sticky="w")

		self.fieldVar = tk.StringVar()
		self.fieldVar.set(self.fields[0])

		fieldMenu = tk.OptionMenu(centerFrame, self.fieldVar, *self.fields, command=lambda value: self.showColorMap())
		fieldMenu.grid(row=1, column=1, columnspan=4, padx=5, pady=5, sticky="e")

		centerFrame.place(relx=0.5, rely=0.0, anchor="n")
		self.CMSettingsFrame.place(relx=0.02,rely=0.65,relwidth=1.00-0.04,relheight=0.25-0.02,anchor="nw")

		# Colormap

		self.colormapCanvas = tk.Canvas(self.page1)

		self.figure1 = matplotlib.figure.Figure()
		self.plot1 = self.figure1.add_subplot()
		self.plot1.set_position([0.125,0.15,0.75-0.075,0.75])


		self.figure1.patch.set_facecolor((240/255,240/255,237/255))
		self.plot1.patch.set_facecolor((240/255,240/255,237/255))

		self.plot1.set_xlabel("x [m]")
		self.plot1.set_ylabel("y [m]")

		self.matplotlibCanvas1 = FigureCanvasTkAgg(self.figure1, self.colormapCanvas)
		self.matplotlibCanvas1.get_tk_widget().pack(side="left", fill="both", expand=1)

		self.colormapCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.65-0.04,anchor="nw")

	def populatePage2(self):
		self.page2 = Page(self.root, width=600, height=500, prevFunc=self.page2Prev, nextFunc=lambda:1)
		self.page2.nextButton.configure(state="disabled")

		def changeTSIntVar(stringVal):
			self.timeStepVar.set( int(stringVal.replace("TimeStep", "")) )

		# Settings

		self.PPSettingsFrame = tk.LabelFrame(self.page2, text="Profile Plot Settings")

		centerFrame = tk.Frame(self.PPSettingsFrame)

		self.directionVar = tk.StringVar(value="y")

		directionMenu = tk.OptionMenu(centerFrame, self.directionVar, *["x", "y"])
		directionMenu.grid(row=0, column=0, padx=5, pady=5)

		tk.Label(centerFrame, text="=").grid(row=0,column=1,padx=5,pady=5)
		tk.Label(centerFrame, text="±").grid(row=0,column=3,padx=5,pady=5)

		self.lineEntry = tk.Entry(centerFrame, width=10)
		self.lineEntry.grid(row=0, column=2, padx=5, pady=5)
		self.lineEntry.bind('<Return>', lambda e:self.plotFieldProfile())

		self.devEntry = tk.Entry(centerFrame, width=10)
		self.devEntry.grid(row=0, column=4, padx=5, pady=5)
		self.devEntry.bind('<Return>', lambda e:self.plotFieldProfile())

		fieldMenu = tk.OptionMenu(centerFrame, self.fieldVar, *self.fields, command=lambda value: self.showColorMap())
		fieldMenu.grid(row=1, column=0, columnspan=3, padx=5, pady=5, sticky="w")

		self.timeStepStrVar = tk.StringVar(value=self.timeSteps[-1])
		timeStepMenu = tk.OptionMenu(centerFrame, self.timeStepStrVar, command=changeTSIntVar, *self.timeSteps)
		timeStepMenu.grid(row=1, column=4, columnspan=2, padx=5, pady=5, sticky="e")

		plotButton = tk.Button(centerFrame, text="Plot", command=self.plotFieldProfile)
		plotButton.bind('<Return>', lambda e:self.plotFieldProfile())
		plotButton.grid(row=0, column=5, padx=5, pady=5, sticky="e")

		self.plotOnCMapVar = tk.BooleanVar(value=False)
		plotOnCMapCheck = tk.Checkbutton(centerFrame, text="Plot on \ncolormap", variable=self.plotOnCMapVar)
		plotOnCMapCheck.grid(row=0,column=6,rowspan=2, sticky="nw")


		centerFrame.place(relx=0.5, rely=0.0, anchor="n")
		self.PPSettingsFrame.place(relx=0.02,rely=0.65,relwidth=1.00-0.04,relheight=0.25-0.02,anchor="nw")

		# Plot

		self.plotCanvas = tk.Canvas(self.page2)

		self.figure2 = matplotlib.figure.Figure()
		self.plot2 = self.figure2.add_subplot()
		self.plot2.set_position([0.125,0.15,0.8,0.75])

		self.figure2.patch.set_facecolor((240/255,240/255,237/255))
		self.plot2.patch.set_facecolor((240/255,240/255,237/255))

		self.plot2.set_title("Plot field along line")

		self.matplotlibCanvas2 = FigureCanvasTkAgg(self.figure2, self.plotCanvas)
		self.matplotlibWidget = self.matplotlibCanvas2.get_tk_widget()
		self.matplotlibWidget.pack(side="left", fill="both", expand=1)

		self.plotCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.65-0.04,anchor="nw")

	def showColorMap(self):
		X,Y = self.coords[:-1]

		try:
			if int( self.timeStepVar.get() ) > self.numberOfTimeSteps or int( self.timeStepVar.get() ) < 1:
				raise Exception
		except:
			tk.messagebox.showwarning("Warning", "Invalid Time Step\nIt must range from 1 to {}".format(self.numberOfTimeSteps))
			raise Exception("Invalid Time Step")

		label = "TimeStep{} - {}".format( self.timeStepVar.get(), self.fieldVar.get())
		numericalField = self.resultsData[label]

		Xi, Yi = np.meshgrid( np.linspace(min(X), max(X), len(X)), np.linspace(min(Y), max(Y), len(Y)) )
		nF = griddata((X,Y), numericalField, (Xi,Yi), method="linear")

		if self.first:
			self.first = False
		else:
			self.cbar.remove()
		try:
			self.cdata = self.plot1.pcolor(Xi,Yi,nF, cmap=CM( cm.get_cmap("RdBu",64)(np.linspace(1,0,64)) )) # Makes BuRd instead of RdBu
		except:
			tk.messagebox.showerror("Error", "Unable to allocate the memory")
			raise Exception("Unable to allocate the memory")
	
		cbaxes = self.figure1.add_axes([0.825, 0.15, 0.03, 0.75]) 
		self.cbar = self.figure1.colorbar(self.cdata, cax=cbaxes)

		self.plot1.set_position([0.125,0.15,0.75-0.075,0.75])
		self.matplotlibCanvas1.draw()

	def plotFieldProfile(self):
		X,Y = self.coords[:-1]
		numberOfVertices = len(X)
		label = "{} - {}".format( self.timeStepStrVar.get(), self.fieldVar.get())

		wStr = self.directionVar.get()
		tStr = "x" if wStr == "y" else "y"

		W = {"x": X, "y": Y}[wStr]
		T = {"x": X, "y": Y}[tStr]

		try:
			# W0(t), dW(t)
			W0 = [ float( self.lineEntry.get() ) ] * numberOfVertices
			if self.devEntry.get() == "":
				dW = [ 0.0 ] * numberOfVertices
			else:
				dW = [ float( self.devEntry.get() ) ] * numberOfVertices
		except:
			try:
				W0 = [ eval( self.lineEntry.get().replace(tStr,str(t)).replace("^", "**") ) for t in T ]
				if self.devEntry.get() == "":
					dW = [ 0.0 ] * numberOfVertices
				else:
					dW = [ eval( self.devEntry.get().replace(tStr,str(t)).replace("^", "**") ) for t in T ]
			except:
				tk.messagebox.showwarning("Warning", "Invalid parameters")
				raise Exception("Invalid parameters")

		self.plot2.clear()
		self.plot2.patch.set_facecolor((240/255,240/255,237/255))

		try:
			# Here w represents the chosen axis, and t the other one
			# The comparison is with the global max and min because the mesh is unstructured
			if not [1 for t,w0,dw in zip(T,W0,dW) if w0+dw>min(W) and w0-dw<max(W)]:
				tk.messagebox.showwarning("Warning", "This range does not contain the domain")
				return
			data = [(t, nR) for w,w0,dw,t,nR in zip(W, W0, dW, T, self.resultsData[label]) if abs(w-w0)<dw]
			if not data:
				tk.messagebox.showwarning("Warning", "No point passes through this range")
				return
			rT, numericalField = zip(*data)
			rT, numericalField = zip(*sorted(zip(rT,numericalField)))
			self.plot2.plot(rT,numericalField, color="k", marker=".")

			self.plot2.set_xlim([min(rT), max(rT)])
			self.plot2.set_ylim([min(self.resultsData[label]), max(self.resultsData[label])])		
			self.plot2.set_xlabel(f"{tStr} [m]")
			self.plot2.set_ylabel(self.fieldVar.get())
			self.matplotlibCanvas2.draw()

		except:
			tk.messagebox.showerror("Error", "An error has occuried")

		if self.plotOnCMapVar.get():
			uT, upper = zip( *[(t, w0+dw) for w0,dw,t in zip(W0,dW,T) if w0+dw<max(W)] )
			lT, lower = zip( *[(t, w0-dw) for w0,dw,t in zip(W0,dW,T) if w0-dw>min(W)] )
			uT, upper = zip(*sorted(zip(uT, upper)))
			lT, lower = zip(*sorted(zip(lT, lower)))
			self.plot1.clear()
			self.showColorMap()
			if wStr == "x":
				self.plot1.plot(lower, lT,color="k", linewidth=0.75)
				self.plot1.plot(upper, uT,color="k", linewidth=0.75)
			elif wStr == "y":
				self.plot1.plot(lT,lower,color="k", linewidth=0.75)
				self.plot1.plot(uT,upper,color="k", linewidth=0.75)
			self.matplotlibCanvas1.draw()

	def page1Prev(self):
		self.page1.hide()
		if self.consoleTextSet:
			self.consolePage.show()
		elif self.returnToSimulator:
			self.simulator.page2.show()
		else:
			self.app.init()

	def page1Next(self):
		self.page1.hide()
		self.page2.show()

	def page2Prev(self):
		self.page2.hide()
		self.page1.show()

	def setResultsPath(self, path):
		self.resultsPath = path
		self.root.title("PyEFVLib GUI - {}".format(path))

	def setOutputTextVar(self, textVar):
		self.outputTextVar = textVar
		self.consoleTextSet = True

	def setSimulator(self, simulator):
		self.simulator = simulator

	def readData(self):
		self.resultsData = pd.read_csv(self.resultsPath)
		self.coords = np.array(self.resultsData[["X","Y","Z"]]).T
		self.fields = list( {"".join(fieldName.split(" - ")[1:]) for fieldName in self.resultsData.columns[3:]} )
		self.timeSteps = [ fieldName.split(" - ")[0] for fieldName in self.resultsData.columns[3:] ]
		self.timeSteps = [ ts for idx, ts in enumerate(self.timeSteps) if ts not in self.timeSteps[:idx] ]
		self.numberOfTimeSteps = len(self.timeSteps)

if __name__ == "__main__":
	app = PyEFVLibGUI()
